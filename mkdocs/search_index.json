{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Data Pipes by Actio", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-data-pipes-by-actio", 
            "text": "", 
            "title": "Welcome to Data Pipes by Actio"
        }, 
        {
            "location": "/configuration/", 
            "text": "PipeScript\n\n\nPipeScript is a language that defines how data retrieval, transformation and loading is coordinated and executed. All pipe scripts are persisted in the \nHOCON\n format and are composed of the following sections:\n\n\nSystem \n Operation Definitions\n\n\n\n\nGlobal Config\n\n\nSystem Endpoints for Config, Events, Instructions\n\n\n\n\nTask Definitions\n\n\n\n\nFunctional Operations on the Data Stream\n\n\n\n\nPipeline Definitions\n\n\n\n\nFlow Control between Tasks and other Pipelines\n\n\n\n\nService Definition\n\n\n\n\nDefine Bind Points to - URI and Adjectives to a pipeline. The return value from the call is the output of the pipeline.\n\n\n\n\nSchedule\n\n\n\n\nDefine a default pipeline to start associated with the specific Config.\n\n\nDefine Active scheduled pipelines \n\n\nDefine Active Services", 
            "title": "Introduction"
        }, 
        {
            "location": "/configuration/#pipescript", 
            "text": "PipeScript is a language that defines how data retrieval, transformation and loading is coordinated and executed. All pipe scripts are persisted in the  HOCON  format and are composed of the following sections:", 
            "title": "PipeScript"
        }, 
        {
            "location": "/configuration/#system-operation-definitions", 
            "text": "Global Config  System Endpoints for Config, Events, Instructions", 
            "title": "System &amp; Operation Definitions"
        }, 
        {
            "location": "/configuration/#task-definitions", 
            "text": "Functional Operations on the Data Stream", 
            "title": "Task Definitions"
        }, 
        {
            "location": "/configuration/#pipeline-definitions", 
            "text": "Flow Control between Tasks and other Pipelines", 
            "title": "Pipeline Definitions"
        }, 
        {
            "location": "/configuration/#service-definition", 
            "text": "Define Bind Points to - URI and Adjectives to a pipeline. The return value from the call is the output of the pipeline.", 
            "title": "Service Definition"
        }, 
        {
            "location": "/configuration/#schedule", 
            "text": "Define a default pipeline to start associated with the specific Config.  Define Active scheduled pipelines   Define Active Services", 
            "title": "Schedule"
        }, 
        {
            "location": "/tasks/", 
            "text": "Tasks\n\n\nTasks perform some operation, usually with a side-effect, on an incoming dataset to produce an outgoing dataset. Tasks at a high level can be of either extract, transform or load type.\nMore specifically the following tasks are supported:\n\n\n\n\nExtract\n - Extracts data from a data source\n\n\nTransform Term\n - Transforms the data source using expressions\n\n\nData Source Find\n - Finds data in the data source matching a criteria\n\n\nData Source Join\n - Joins the incoming data to data from the data source using matching compound keys\n\n\nData Source Update\n - Executes either create or update commands to the datasource depending on matching compound keys\n\n\nLoad\n - Executes commands to the datasource\n\n\nDump\n - Displays the incoming dataset on the console\n\n\nFile Dump\n - Persists the incoming dataset to disk\n\n\n\n\nA typical extraction task is defined as follows:\n\n\nread_my_api {\n  type = \nextract\n\n  dataSource = \n${\nmy_datasource\n}\n\n  dataSource {\n    query {\n      read {\n        uri = \n${\nmy_datasource\n.\nbase_uri\n}\n/v1/users\n\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\nNote\n\n\nThe type field within the task matches one of the predefined task types.\nAlso notice the data source details can be specified outside of the task so that it can be reused.", 
            "title": "Tasks"
        }, 
        {
            "location": "/tasks/#tasks", 
            "text": "Tasks perform some operation, usually with a side-effect, on an incoming dataset to produce an outgoing dataset. Tasks at a high level can be of either extract, transform or load type.\nMore specifically the following tasks are supported:   Extract  - Extracts data from a data source  Transform Term  - Transforms the data source using expressions  Data Source Find  - Finds data in the data source matching a criteria  Data Source Join  - Joins the incoming data to data from the data source using matching compound keys  Data Source Update  - Executes either create or update commands to the datasource depending on matching compound keys  Load  - Executes commands to the datasource  Dump  - Displays the incoming dataset on the console  File Dump  - Persists the incoming dataset to disk   A typical extraction task is defined as follows:  read_my_api {\n  type =  extract \n  dataSource =  ${ my_datasource } \n  dataSource {\n    query {\n      read {\n        uri =  ${ my_datasource . base_uri } /v1/users \n      }\n    }\n  }\n}   Note  The type field within the task matches one of the predefined task types.\nAlso notice the data source details can be specified outside of the task so that it can be reused.", 
            "title": "Tasks"
        }, 
        {
            "location": "/datasources/", 
            "text": "Introduction\n\n\nData sources define systems where data can be retrieved and manipulated. Queries defined within the data sources are ways of interacting with that system and its use depends on the communication protocol of that data source.\n\n\nData source queries that extract data out of a system will produce data sets, while manipulation of the data source data will require the data source to consume data sets.\n\n\nAll data source queries allow for templating so that incoming data can potentially be used to produce different queries.", 
            "title": "Data Sources"
        }, 
        {
            "location": "/datasources/#introduction", 
            "text": "Data sources define systems where data can be retrieved and manipulated. Queries defined within the data sources are ways of interacting with that system and its use depends on the communication protocol of that data source.  Data source queries that extract data out of a system will produce data sets, while manipulation of the data source data will require the data source to consume data sets.  All data source queries allow for templating so that incoming data can potentially be used to produce different queries.", 
            "title": "Introduction"
        }, 
        {
            "location": "/pipelines/", 
            "text": "Pipelines", 
            "title": "Pipelines"
        }, 
        {
            "location": "/pipelines/#pipelines", 
            "text": "", 
            "title": "Pipelines"
        }, 
        {
            "location": "/commandline/", 
            "text": "Command Line\n\n\nData pipes runs on the JVM and can be executed as follows:\n\n\njava -cp ./config:./dpipes-assembly.jar com.actio.Main -c \nconfigName.conf\n \n[\n-p \npipeName\n]", 
            "title": "Command Line"
        }, 
        {
            "location": "/commandline/#command-line", 
            "text": "Data pipes runs on the JVM and can be executed as follows:  java -cp ./config:./dpipes-assembly.jar com.actio.Main -c  configName.conf   [ -p  pipeName ]", 
            "title": "Command Line"
        }, 
        {
            "location": "/datasets/", 
            "text": "DataSets\n\n\nDataSets are hierarchical data structures.\nThe following is an example of a DataSet representing a person object:\n\n\n(\nperson\n,\n\n  \nfirstName\n \n-\n \nJohn\n,\n\n  \nlastName\n \n-\n \nSmith\n,\n\n  \n(\naddress\n,\n\n    \naddr1\n \n-\n \nGeorge St.\n,\n\n    \naddr2\n \n-\n \nSydney\n,\n\n    \npostcode\n \n-\n \n2000\n),\n\n  \n[\nphoneNumbers\n,\n    \nitem\n \n-\n \n98765432\n,\n    \nitem\n \n-\n \n87654321\n,\n    \nitem\n \n-\n \n76543212\n])\n\n\n\n\n\n\nThe following JSON is an identical representation of the previous DataSet.\n\n\n{\n\n  \nperson\n:\n \n{\n\n    \nfirstName\n:\n \nJohn\n,\n\n    \nlastName\n:\n \nSmith\n,\n\n    \naddress\n:\n \n{\n\n      \naddr1\n:\n \nGeorge St.\n,\n\n      \naddr2\n:\n \nSydney\n,\n\n      \npostcode\n:\n \n2000\n\n    \n},\n\n    \nphoneNumbers\n:\n \n[\n\n      \n98765432\n,\n\n      \n87654321\n,\n\n      \n76543212\n\n    \n]\n\n  \n}\n\n\n}\n\n\n\n\n\n\nPrimitive DataSet Types\n\n\nThe following\n\n\nString:\n\n\nfirstName\n \n-\n \nJohn\n\n\n\n\n\n\nNumeric:\n\n\npostcode\n \n-\n \n2000\n\n\n\n\n\n\nDate:\n\n\ndob\n \n-\n \n2000-01-01 00:00:00\n\n\n\n\n\n\nBoolean:\n\n\ncitizen\n \n-\n \ntrue\n\n\n\n\n\n\nRecord:\n\n\n(\naddress\n,\n\n  \naddr1\n \n-\n \nGeorge St.\n,\n\n  \naddr2\n \n-\n \nSydney\n,\n\n  \npostcode\n \n-\n \n2000\n)\n\n\n\n\n\n\nArray:\n\n\n[\nphoneNumbers\n,\n  \nitem\n \n-\n \n98765432\n,\n  \nitem\n \n-\n \n87654321\n,\n  \nitem\n \n-\n \n76543212\n]\n\n\n\n\n\n\nEmpty:\n\n\n()", 
            "title": "Data Sets"
        }, 
        {
            "location": "/datasets/#datasets", 
            "text": "DataSets are hierarchical data structures.\nThe following is an example of a DataSet representing a person object:  ( person , \n   firstName   -   John , \n   lastName   -   Smith , \n   ( address , \n     addr1   -   George St. , \n     addr2   -   Sydney , \n     postcode   -   2000 ), \n   [ phoneNumbers ,\n     item   -   98765432 ,\n     item   -   87654321 ,\n     item   -   76543212 ])   The following JSON is an identical representation of the previous DataSet.  { \n   person :   { \n     firstName :   John , \n     lastName :   Smith , \n     address :   { \n       addr1 :   George St. , \n       addr2 :   Sydney , \n       postcode :   2000 \n     }, \n     phoneNumbers :   [ \n       98765432 , \n       87654321 , \n       76543212 \n     ] \n   }  }", 
            "title": "DataSets"
        }, 
        {
            "location": "/datasets/#primitive-dataset-types", 
            "text": "The following  String:  firstName   -   John   Numeric:  postcode   -   2000   Date:  dob   -   2000-01-01 00:00:00   Boolean:  citizen   -   true   Record:  ( address , \n   addr1   -   George St. , \n   addr2   -   Sydney , \n   postcode   -   2000 )   Array:  [ phoneNumbers ,\n   item   -   98765432 ,\n   item   -   87654321 ,\n   item   -   76543212 ]   Empty:  ()", 
            "title": "Primitive DataSet Types"
        }, 
        {
            "location": "/selection/", 
            "text": "Selection\n\n\nWe will be using the following DataSet to illustrate the selection capabilities:\n\n\n(\nperson\n,\n\n  \nfirstName\n \n-\n \nJohn\n,\n\n  \nlastName\n \n-\n \nSmith\n,\n\n  \n(\naddress\n,\n\n    \naddr1\n \n-\n \nGeorge St.\n,\n\n    \naddr2\n \n-\n \nSydney\n,\n\n    \npostcode\n \n-\n \n2000\n),\n\n  \n[\nphoneNumbers\n,\n    \nitem\n \n-\n \n98765432\n,\n    \nitem\n \n-\n \n87654321\n,\n    \nitem\n \n-\n \n76543212\n])\n\n\n\n\n\n\nBy Name\n\n\nTo access the persons postcode one can use the following familiar syntax:\n\n\naddress\n.\npostcode\n\n\n\n\n\n\nThis returns the following DataSet:\n\n\npostcode\n \n-\n \n2000\n\n\n\n\n\n\n\n\nWarning\n\n\nAccessing an element that does not exist will simply return an empty DataSet:\n\n\naddress.suburb\n\n\nwill return an empty DataSet:\n\n\n( )\n\n\n\n\nBy Index\n\n\nTo access the first phone number:\n\n\nphoneNumbers\n(\n0\n)\n\n\n\n\n\n\nThis returns the following DataSet:\n\n\nitem\n \n-\n \n98765432\n\n\n\n\n\n\n\n\nWarning\n\n\nAccessing an element that does not exist will simply return an empty DataSet:\n\n\naddress.suburb\n\n\nwill return an empty DataSet:\n\n\n( )", 
            "title": "Selection"
        }, 
        {
            "location": "/selection/#selection", 
            "text": "We will be using the following DataSet to illustrate the selection capabilities:  ( person , \n   firstName   -   John , \n   lastName   -   Smith , \n   ( address , \n     addr1   -   George St. , \n     addr2   -   Sydney , \n     postcode   -   2000 ), \n   [ phoneNumbers ,\n     item   -   98765432 ,\n     item   -   87654321 ,\n     item   -   76543212 ])", 
            "title": "Selection"
        }, 
        {
            "location": "/selection/#by-name", 
            "text": "To access the persons postcode one can use the following familiar syntax:  address . postcode   This returns the following DataSet:  postcode   -   2000    Warning  Accessing an element that does not exist will simply return an empty DataSet:  address.suburb  will return an empty DataSet:  ( )", 
            "title": "By Name"
        }, 
        {
            "location": "/selection/#by-index", 
            "text": "To access the first phone number:  phoneNumbers ( 0 )   This returns the following DataSet:  item   -   98765432    Warning  Accessing an element that does not exist will simply return an empty DataSet:  address.suburb  will return an empty DataSet:  ( )", 
            "title": "By Index"
        }, 
        {
            "location": "/operators/", 
            "text": "Operators\n\n\nNumeric Operators\n\n\nThe following numeric operators are supported when both a and b are numeric values:\n\n\n\n\na + b\n - Adds a and b.\n\n\na - b\n - Substracts b from a.\n\n\na * b\n - Multiplies a and b.\n\n\na / b\n - Devides b from a.\n\n\n\n\n\n\nNote\n\n\nIf a or b isn't a number, \nEmpty\n is returned.\n\n\n\n\nThe following unary operator will negate the numeric value a:\n\n\n\n\n-a\n - Negative a.\n\n\n\n\n\n\nNote\n\n\nIf a isn't a number, \nEmpty\n is returned.\n\n\n\n\nString Operators\n\n\nThe following string operator concatenates both strings:\n\n\n\n\na + b\n - Concatenates a and b.\n\n\n\n\nBoolean Operators\n\n\n\n\na \n b\n - Returns a AND b.\n\n\na || b\n - Returns a OR b.\n\n\n\n\nRelational Operators\n\n\n\n\na \n b\n - Returns whether a is less than b.\n\n\na \n b\n - Returns whether a is greater than b.\n\n\na \n= b\n - Returns whether a is less than or equal b.\n\n\na \n= b\n - Returns whether a is greater than or equal b.", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#operators", 
            "text": "", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#numeric-operators", 
            "text": "The following numeric operators are supported when both a and b are numeric values:   a + b  - Adds a and b.  a - b  - Substracts b from a.  a * b  - Multiplies a and b.  a / b  - Devides b from a.    Note  If a or b isn't a number,  Empty  is returned.   The following unary operator will negate the numeric value a:   -a  - Negative a.    Note  If a isn't a number,  Empty  is returned.", 
            "title": "Numeric Operators"
        }, 
        {
            "location": "/operators/#string-operators", 
            "text": "The following string operator concatenates both strings:   a + b  - Concatenates a and b.", 
            "title": "String Operators"
        }, 
        {
            "location": "/operators/#boolean-operators", 
            "text": "a   b  - Returns a AND b.  a || b  - Returns a OR b.", 
            "title": "Boolean Operators"
        }, 
        {
            "location": "/operators/#relational-operators", 
            "text": "a   b  - Returns whether a is less than b.  a   b  - Returns whether a is greater than b.  a  = b  - Returns whether a is less than or equal b.  a  = b  - Returns whether a is greater than or equal b.", 
            "title": "Relational Operators"
        }, 
        {
            "location": "/functions/", 
            "text": "Functions\n\n\nString Functions\n\n\nThe following functions can be used:\n\n\ndef\n \nstrContains\n(\nsource\n:\n \nString\n,\n \ntarget\n:\n \nString\n)\n:\n \nBool\n\n\n\n\n\n\nReturns true if the target string can be found in the source string.\n\n\ndef\n \nsubstring\n(\nsource\n:\n \nString\n,\n \nstart\n:\n \nInt\n)\n:\n \nString\n\n\n\n\n\n\nReturns the remainder string beginning at index start.\n\n\nGeneric Functions\n\n\ndef\n \ncoalesce\n(\nxs\n:\n \nDataSet*\n)\n:\n \nDataSet\n\n\n\n\n\n\nReturns the first DataSet that is not empty.", 
            "title": "Functions"
        }, 
        {
            "location": "/functions/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/functions/#string-functions", 
            "text": "The following functions can be used:  def   strContains ( source :   String ,   target :   String ) :   Bool   Returns true if the target string can be found in the source string.  def   substring ( source :   String ,   start :   Int ) :   String   Returns the remainder string beginning at index start.", 
            "title": "String Functions"
        }, 
        {
            "location": "/functions/#generic-functions", 
            "text": "def   coalesce ( xs :   DataSet* ) :   DataSet   Returns the first DataSet that is not empty.", 
            "title": "Generic Functions"
        }, 
        {
            "location": "/conditionals/", 
            "text": "Conditionals\n\n\nThe following block demonstrates the usage of conditionals:\n\n\nif\n \n(\nc1\n)\n \na\n\n  \nelse\n \nif\n(\nc2\n)\n \nb\n\n  \n[\nelse\n \nif...\n]\n\n  \nelse\n \nc\n\n\n\n\n\n\nIf condition c1 is true, then return a.\nIf condition c1 is not true, but c2 is true, return b.\nOtherwise return c.", 
            "title": "Conditionals"
        }, 
        {
            "location": "/conditionals/#conditionals", 
            "text": "The following block demonstrates the usage of conditionals:  if   ( c1 )   a \n   else   if ( c2 )   b \n   [ else   if... ] \n   else   c   If condition c1 is true, then return a.\nIf condition c1 is not true, but c2 is true, return b.\nOtherwise return c.", 
            "title": "Conditionals"
        }, 
        {
            "location": "/templates/", 
            "text": "Templates\n\n\nTemplates perform string interpolation and follow the Scala syntax using the dollar operator with brackets required with more complex expressions:\n\n\n$firstName $lastName lives in a suburb with postcode ${address.postcode}.\n\n\n\n\n\n\n\n\nWarning\n\n\nThe top level expressions used within a template will always be evaluated to a string. The empty string will be used if the expression cannot be evaluated to a string.\n\n\n\n\nTemplates can be used to generate XML, JSON, SQL, CSV and in general any structure that can be thought of as a string.\n\n\nXML\n\n\nroot\n\n  \nfirstName\n$firstName\n/firstName\n\n  \nlastName\n$lastName\n/lastName\n\n\n/root\n\n\n\n\n\n\nJSON\n\n\n{\n\n  \nfirstName\n:\n \n$firstName\n,\n\n  \nlastName\n:\n \n$lastName\n,\n\n\n}\n\n\n\n\n\n\nSQL\n\n\nselect\n \n*\n \nfrom\n \nperson\n \nwhere\n \nfirstName\n \n=\n \n$firstName\n \nAND\n \nlastName\n \n=\n \n$lastName\n\n\n\n\n\n\nCSV\n\n\n$firstName,$lastName", 
            "title": "Templates"
        }, 
        {
            "location": "/templates/#templates", 
            "text": "Templates perform string interpolation and follow the Scala syntax using the dollar operator with brackets required with more complex expressions:  $firstName $lastName lives in a suburb with postcode ${address.postcode}.    Warning  The top level expressions used within a template will always be evaluated to a string. The empty string will be used if the expression cannot be evaluated to a string.   Templates can be used to generate XML, JSON, SQL, CSV and in general any structure that can be thought of as a string.", 
            "title": "Templates"
        }, 
        {
            "location": "/templates/#xml", 
            "text": "root \n   firstName $firstName /firstName \n   lastName $lastName /lastName  /root", 
            "title": "XML"
        }, 
        {
            "location": "/templates/#json", 
            "text": "{ \n   firstName :   $firstName , \n   lastName :   $lastName ,  }", 
            "title": "JSON"
        }, 
        {
            "location": "/templates/#sql", 
            "text": "select   *   from   person   where   firstName   =   $firstName   AND   lastName   =   $lastName", 
            "title": "SQL"
        }, 
        {
            "location": "/templates/#csv", 
            "text": "$firstName,$lastName", 
            "title": "CSV"
        }, 
        {
            "location": "/datasources/", 
            "text": "Introduction\n\n\nData sources define systems where data can be retrieved and manipulated. Queries defined within the data sources are ways of interacting with that system and its use depends on the communication protocol of that data source.\n\n\nData source queries that extract data out of a system will produce data sets, while manipulation of the data source data will require the data source to consume data sets.\n\n\nAll data source queries allow for templating so that incoming data can potentially be used to produce different queries.", 
            "title": "Introduction"
        }, 
        {
            "location": "/datasources/#introduction", 
            "text": "Data sources define systems where data can be retrieved and manipulated. Queries defined within the data sources are ways of interacting with that system and its use depends on the communication protocol of that data source.  Data source queries that extract data out of a system will produce data sets, while manipulation of the data source data will require the data source to consume data sets.  All data source queries allow for templating so that incoming data can potentially be used to produce different queries.", 
            "title": "Introduction"
        }, 
        {
            "location": "/datasource_file/", 
            "text": "File data sources allows one to extract the contents of files that match a regular expression. The following template is the minimum required for the use of different file types.\n\n\ndataSource {\n    type = file\n    behavior = ?\n    query {\n        read {\n            directory = \n/home/me\n\n            filenameTemplate = \nmyfile.dat\n\n        }\n    }\n}\n\n\n\n\n\n\n\nNote\n\n\nThe property behavior can be set to any of the following: {csv, raw, dbf}\n\n\n\n\nText File\n\n\ndataSource {\n    type = file\n    behavior = raw\n\n    query {\n        read {\n            directory = \n/home/me\n\n            filenameTemplate = \nfileName.txt\n\n        }\n        create {\n            directory = \n/home/me\n\n            filenameTemplate = \nfileName.txt\n\n            header = \nC1,C2,C3\n\n            line = \n$c1,$c2,$c3\n\n        }\n    }\n}\n\n\n\n\n\nDBF File\n\n\ndataSource {\n    type = file\n    behavior = DBF\n    query {\n        read {\n            directory = \n/home/me\n\n            filenameTemplate = \nfileName.DBF\n\n            fields = [\nC1\n, \nC2\n, \nC3\n]\n        }\n    }\n}", 
            "title": "Files"
        }, 
        {
            "location": "/datasource_file/#text-file", 
            "text": "dataSource {\n    type = file\n    behavior = raw\n\n    query {\n        read {\n            directory =  /home/me \n            filenameTemplate =  fileName.txt \n        }\n        create {\n            directory =  /home/me \n            filenameTemplate =  fileName.txt \n            header =  C1,C2,C3 \n            line =  $c1,$c2,$c3 \n        }\n    }\n}", 
            "title": "Text File"
        }, 
        {
            "location": "/datasource_file/#dbf-file", 
            "text": "dataSource {\n    type = file\n    behavior = DBF\n    query {\n        read {\n            directory =  /home/me \n            filenameTemplate =  fileName.DBF \n            fields = [ C1 ,  C2 ,  C3 ]\n        }\n    }\n}", 
            "title": "DBF File"
        }, 
        {
            "location": "/datasource_ftp/", 
            "text": "dataSource {\n    type = ftp_client\n    connect = \nlocalhost\n\n    port = 1632\n    credential {\n        user = \nusername\n\n        password = \npassword\n\n    }\n    query {\n        read {\n            remotepath = \n/home/me\n\n            remote_file = \nmyfile.dat\n\n        }\n    }\n}", 
            "title": "FTP"
        }, 
        {
            "location": "/datasource_jdbc/", 
            "text": "SQL Jdbc\n\n\ndataSource {\n        type = sql\n        connect = \njdbc:postgresql://localhost/my_db?user=me\npassword=password\n\n        query {\n            read = \nselect c1,c2 from T1\n\n            create = \ninsert into T1 values ($v1,$v2)\n\n        }\n}", 
            "title": "JDBC"
        }, 
        {
            "location": "/datasource_jdbc/#sql-jdbc", 
            "text": "dataSource {\n        type = sql\n        connect =  jdbc:postgresql://localhost/my_db?user=me password=password \n        query {\n            read =  select c1,c2 from T1 \n            create =  insert into T1 values ($v1,$v2) \n        }\n}", 
            "title": "SQL Jdbc"
        }, 
        {
            "location": "/datasource_rest/", 
            "text": "REST Json\n\n\ndataSource {\n    type = rest\n    credential {\n        user = \nme\n\n        password = \npassword\n\n    }\n    headers {\n        mykey1 = \nmyvalue1\n\n        mykey2 = \nmyvalue2\n\n    }\n    query {\n        read {\n            uri = \nhttps://mydomain.com/v1/users\n\n        }\n        create {\n            verb = put\n            uri = \nhttps://mydomain.com/v1/users\n\n            body = \n$body\n\n        }\n    }\n}", 
            "title": "REST"
        }, 
        {
            "location": "/datasource_rest/#rest-json", 
            "text": "dataSource {\n    type = rest\n    credential {\n        user =  me \n        password =  password \n    }\n    headers {\n        mykey1 =  myvalue1 \n        mykey2 =  myvalue2 \n    }\n    query {\n        read {\n            uri =  https://mydomain.com/v1/users \n        }\n        create {\n            verb = put\n            uri =  https://mydomain.com/v1/users \n            body =  $body \n        }\n    }\n}", 
            "title": "REST Json"
        }
    ]
}